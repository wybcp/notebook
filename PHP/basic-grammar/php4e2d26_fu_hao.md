# php中&符号
http://blog.163.com/meng_qiang/blog/static/17735437320114232510852/

php的引用（就是在变量或者函数、对象等前面加上&符号） 

在PHP 中引用的意思是：不同的名字访问同一个变量内容. 
与Ｃ语言中的指针是有差别的．Ｃ语言中的指针里面存储的是变量的内容在内存中存放的地址 

##变量的引用 

PHP 的引用允许你用两个变量来指向同一个内容 
```
<?php 
$a="ABC"; 
$b =&$a; 
echo $a;//这里输出:ABC 
echo $b;//这里输出:ABC 
$b="EFG"; 
echo $a;//这里$a的值变为EFG所以输出EFG 
echo $b;//这里输出EFG 
?> 
```

##函数的传址调用 
```
<?php
function test(&$a) 
{ 
$a=$a+100; 
} 
$b=1; 
echo $b;//输出１ 
test($b);   //这里$b传递给函数的其实是$b的变量内容所处的内存地址，通过在函数里改变$a的值　就可以改变$b的值了 
echo "<br>"; 
echo $b;//输出101 
?>
```

##函数的引用返回 
```
<?php
function &test() 
{ 
static $b=0;//申明一个静态变量 
$b=$b+1; 
echo $b; 
return $b; 
} 

$a=test();//这条语句会输出$b的值为１ 
$a=5; 
$a=test();//这条语句会输出$b的值为2 

$a=&test();//这条语句会输出$b的值为3 
$a=5; 
$a=test();//这条语句会输出$b的值为6 
?>
```


通过这种方式`$a=test();`得到的其实不是函数的引用返回;

ＰＨＰ规定通过`$a=&test(); `方式得到的才是函数的引用返回 。

引用返回用在当想用函数找到引用应该被绑定在哪一个变量上面时。

用上面的例子来解释就是:

$a=test()方式调用函数，只是将函数的值赋给$a而已，而$a做任何改变都不会影响到函数中的$b ;

而通过$a=&test()方式调用函数呢, 是将return $b中的$b变量的内存地址与$a变量的内存地址指向了同一个地方 
即产生了相当于这样的效果($a=&b;) 所以改变$a的值也同时改变了$b的值.

这里是为了让大家理解函数的引用返回才使用静态变量的，其实函数的引用返回多用在对象中 

##对象的引用 
```
<?php 
class a{ 
var $abc="ABC"; 
} 
$b=new a; 
$c=$b; 
echo $b->abc;//这里输出ABC 
echo $c->abc;//这里输出ABC 
$b->abc="DEF"; 
echo $c->abc;//这里输出DEF 
?> 
``` 
在PHP5中对象的复制是通过引用来实现的。上列中$b=new a; $c=$b; 其实等效于$b=new a; $c=&$b; 
PHP5中默认就是通过引用来调用对象， 但有时你可能想建立一个对象的副本，并希望原来的对象的改变不影响到副本 . 为了这样的目的，PHP定义了一个特殊的方法，称为__clone. 

引用的作用 
如果程序比较大,引用同一个对象的变量比较多,并且希望用完该对象后手工清除它,个人建议用 "&" 方式,然后用$var=null的方式清除. 其它时候还是用php5的默认方式吧. 另外, php5中对于大数组的传递,建议用 "&" 方式, 毕竟节省内存空间使用。 


取消引用 
当你 unset 一个引用，只是断开了变量名和变量内容之间的绑定。这并不意味着变量内容被销毁了。例如： 

<?php 
$a = 1; 
$b =& $a; 
unset ($a); 
?>  

不会 unset $b，只是 $a。 


global 引用 
当用 global $var 声明一个变量时实际上建立了一个到全局变量的引用。也就是说和这样做是相同的： 

<?php 
$var =& $GLOBALS["var"]; 
?>  

这意味着，例如，unset $var 不会 unset 全局变量。 

$this 
在一个对象的方法中，$this 永远是调用它的对象的引用。 


//下面再来个小插曲 
php中对于地址的指向（类似指针）功能不是由用户自己来实现的，是由Zend核心实现的，php中引用采用的是“写时拷贝”的原理，就是除非发生写操作，指向同一个地址的变量或者对象是不会被拷贝的。 

通俗的讲 
1:如果有下面的代码 
[php] 
$a="ABC"; 
$b=$a; 
[/php] 
其实此时　$a与$b都是指向同一内存地址　而并不是$a与$b占用不同的内存 

２:如果在上面的代码基础上再加上如下代码 
[php] 
$a="EFG"; 
[/php] 
由于$a与$b所指向的内存的数据要重新写一次了，此时Zend核心会自动判断　自动为$b生产一个$a的数据拷贝，重新申请一块内存进行存储
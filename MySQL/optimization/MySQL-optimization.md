# mysql 优化

- 不要查询不需要的列
- 不要在多表关联返回全部的列
- 不要 `select *`
- 不要重复查询，应当写入缓存
- 尽量使用关联查询来替代子查询。
- 尽量使用索引优化。如果不使用索引。mysql 则使用临时表或者文件排序。如果不关心结果集的顺序，可以使用 order by null 禁用文件排序。
- 优化分页查询，最简单的就是利用覆盖索引扫描。而不是查询所有的列
- 应尽量避免在 where 子句中使用 !=或<> 操作符，否则将引擎放弃使用索引而进行全表扫描。
- 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引

- 尽量不要使用前缀%

  ```sql
  select * from user where name like '%a'
  ```

- 应尽量避免在 where 子句中对字段进行表达式操作
- 应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描
- 很多时候用 exists 代替 in 是一个好的选择：
- 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。
- 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：

  ```sql
  select id from t where num is null;# 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num=
  ```

- 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：

  ```sql
  select id from t where num=10 or num=20;
  #可以这样查询：
  select id from t where num=10 union all select id from t where num=20;
  ```

## 优化查询过程中的数据访问

- 访问数据太多导致查询性能下降
- 确定应用程序是否在检索大量超过需要的数据，可能是太多行或列
- 确认 MySQL 服务器是否在分析大量不必要的数据行
- 避免犯如下 SQL 语句错误
- 查询不需要的数据。解决办法：使用 limit 解决
- 多表关联返回全部列。解决办法：指定列名
- 总是返回全部列。解决办法：避免使用 `SELECT *`
- 重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存
- 是否在扫描额外的记录。解决办法：
- 使用 explain 进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：
- 使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。
- 改变数据库和表的结构，修改数据表范式
- 重写 SQL 语句，让优化器可以以更优的方式执行查询。

## 优化长难的查询语句

- 一个复杂查询还是多个简单查询
- MySQL 内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多
- 使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。
- 切分查询
- 将一个大的查询分为多个小的相同的查询
- 一次性删除 1000 万的数据要比一次删除 1 万，暂停一会的方案更加损耗服务器开销。
- 分解关联查询，让缓存的效率更高。
- 执行单个查询可以减少锁的竞争。
- 在应用层做关联更容易对数据库进行拆分。
- 查询效率会有大幅提升。
- 较少冗余记录的查询。

## 优化特定类型的查询语句

- `count(*)`会忽略所有的列，直接统计所有列数，不要使用 `count(列名)`
- MyISAM 中，没有任何 where 条件的 `count(*)`非常快。
- 当有 where 条件时，MyISAM 的 count 统计不一定比其它引擎快。
- 可以使用 explain 查询近似值，用近似值替代 `count(*)`
- 增加汇总表
- 使用缓存

## 优化关联查询

- 确定 ON 或者 USING 子句中是否有索引。
- 确保 GROUP BY 和 ORDER BY 只有一个表中的列，这样 MySQL 才有可能使用索引。

## 优化子查询

- 用关联查询替代
- 优化 GROUP BY 和 DISTINCT
- 这两种查询据可以使用索引来优化，是最有效的优化方法
- 关联查询中，使用标识列分组的效率更高
- 如果不需要 ORDER BY，进行 GROUP BY 时加 ORDER BY NULL，MySQL 不会再进行文件排序。
- WITH ROLLUP 超级聚合，可以挪到应用程序处理

## 优化插入

- 禁用索引，大量插入时可以禁用索引`alter table table_name disable keys;`，开启索引`alter table table_name enable keys;`
- 禁用唯一性检查，插入的记录进行唯一性校验，可禁用`set unique_checks=0;`开启`set unique_checks=1;`
- 批量插入
- 禁用外键检查，`set foreign_key_checks=0;`开启`set foreign_key_checks=1;`
- 禁用事务自动提交，`set autocommit=0;`开启`set autocommit=1;`

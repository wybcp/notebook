# 表设计

## mysql 三范式

一共有六种范式，各种范式呈递次规范，越高的范式数据库冗余越低。

### 第一范式：属性原子性不可分割

第一范式是最基本的范式。

数据库表中的所有字段值都是不可分解的原子值。

比如在一个用户表存在一个字段班级叫 3 年级 2 班。这个属性就不符合第一范式。这个字段可以分成 3 年级、2 班

### 第二范式：非主键字段和主键直接关联

第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。

比如订单表 ![订单表](https://pic002.cnblogs.com/images/2012/270324/2012040114063976.png)

在这个表中，存在订单信息和用户信息，和订单不是直接相关的

### 第三范式：消除依赖传递

如果某一属性依赖于其他非主键属性，而其他非主键属性又依赖于主键，那么这个属性就是间接依赖于主键，这被称作传递依赖于主属性。 **通俗解释就是一张表最多只存两层同类型信息**

### 反三范式

没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，提高读性能，就必须降低范式标准，适当保留冗余数据。具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，减少了查询时的关联，提高查询效率，因为在数据库的操作中查询的比例要远远大于 DML 的比例。但是反范式化一定要适度，并且在原本已满足三范式的基础上再做调整的

## [分析表](https://mp.weixin.qq.com/s/1MsyxhtG6Zk3Q9gIV2QVbA)

### ANALYZE TABLE 作用

- ANALYZE TABLE 会统计索引分布信息，并将结果持久化存储；
- 对于 MyISAM 表，相当于执行了一次 myisamchk –analyze；
- 支持 InnoDB、NDB、MyISAM 等存储引擎，但不支持 **视图**（view）；
- ANALYZE TABLE 也可以用在表分区上；
- 对 InnoDB、MyISAM 表执行 ANALYZE TABLE 时，会加上**读锁**（read lock）；
- 执行 ANALYZE TABLE 会记录 binlog。（这是合理的，因为索引分析这个操作，在 MASTER 端执行完后，SLAVE 端也是需要的）

### 关于 innodb_stats_persistent 选项

我们可以通过设定该选项，决定索引分析结果**是否要持久化存储到磁盘中**。

不持久化存储的话，可能需要频繁更新统计信息，并由此引发执行计划反复变化。

这个设置在每个表创建（或后期 ALTER 修改）时都可以自行指定 **STATS_PERSISTENT** 选项，也可以设置全局选项 **innodb_stats_persistent**（这个选项设置为 1 时，则表统计信息将持久化存储）。

### 关于 innodb_stats_persistent_sample_pages 选项

该选项决定了每次统计索引及其他信息时要采集多少个 data page，默认值是 20。

增加这个值，可以提高统计信息的精确度，同样也能提高执行计划的准确性，不过也相应增加了在 InnoDB 表上分析的 I/O 开销。

- 增加 innodb_stats_persistent_sample_pages 的值可能导致 ANALYZE TABLE 的耗时增加。可以参考下方公式估算执行 ANALYZE TABLE 的代价。
- 只有在 innodb_stats_persistent 选项启用后，innodb_stats_persistent_sample_pages 也才能跟着生效，否则的话，只有选项 innodb_stats_transient_sample_pages 才能生效。
- 选项 innodb_stats_transient_sample_pages 设定的是 **动态** 统计信息采集的 data page 数量，默认值是 8。

选项 innodb_stats_persistent_sample_pages 是全局作用的，但如果某个表想单独定义采集的 page 数目，可以在 DDL 时自行设定：

```sql
CREATE TABLE ... STATS_SAMPLE_PAGES = 30;
```

或

```sql
ALTER TABLE ... STATS_SAMPLE_PAGES = 30;
```

## 大表优化

当 MySQL 单表记录数过大时，数据库的 CRUD 性能会明显下降，一些常见的优化措施如下：

1. 限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句。
2. 读/写分离： 经典的数据库拆分方案，主库负责写，从库负责读；
3. 缓存： 使用 MySQL 的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；
4. 垂直分区：根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表（连接查询信息），甚至放到单独的库做分库。

## 垂直拆分

简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。

垂直拆分的优点： 可以使得行数据变小，在查询时减少读取的 Block 数，减少 I/O 次数。此外，垂直分区可以简化表的结构，易于维护。

垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起 Join 操作，可以通过在应用层进行 Join 来解决。此外，垂直分区会让事务变得更加复杂；

## 水平分区

保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。

水平拆分是指数据表行的拆分，表的行数超过 200 万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。

需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升 MySQL 并发能力没有什么意义，所以 水平拆分最好分库 。

水平拆分能够支持非常大的数据量存储，应用端改造也少，但分片事务难以解决 ，跨界点 Join 性能较差，逻辑复杂。

《Java 工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络 I/O。

下面补充一下数据库分片的两种常见方案：

- 客户端代理： 分片逻辑在应用端，封装在 jar 包中，通过修改或者封装 JDBC 层来实现。 当当网的 Sharding-JDBC 、阿里的 TDDL 是两种比较常用的实现。
- 中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat、360 的 Atlas、网易的 DDB 等等都是这种架构的实现。

# MySQL 存储引擎

## MyISAM 存储引擎

不支持事务、也不支持外键，优势是访问速度快，对事务完整性没有 要求或者以 select，insert 为主的应用基本上可以用这个引擎来创建表

支持 3 种不同的存储格式，分别是：静态表；动态表；压缩表

静态表：表中的字段都是非变长字段，这样每个记录都是固定长度的，优点存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多（因为存储时会按照列的宽度定义补足空格）ps：在取数据的时候，默认会把字段后面的空格去掉，如果不注意会把数据本身带的空格也会忽略。

动态表：记录不是固定长度的，这样存储的优点是占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行 OPTIMIZE TABLE 或者 myisamchk-r 命令来改善性能

压缩表：因为每个记录是被单独压缩的，所以只有非常小的访问开支

MyISAM 的表存储成 3 个文件。文件的名字与表名相同。拓展名为*frm*、_MYD_、_MYI_。其实，frm 文件存储表的结构；MYD 文件存储数据，是 MYData 的缩写；MYI 文件存储索引，是 MYIndex 的缩写。

MyISAM：只支持表级锁，只支持表级锁，用户在操作 myisam 表时，select，update，delete，insert 语句都会给表自动加锁。

- 拥有全文索引、压缩、空间函数。
- 不支持事务和行级锁、不支持崩溃后的安全恢复。
- 表存储在两个文件，MYD 和 MYI。
- 设计简单，某些场景下性能很好，例如获取整个表有多少条数据，性能很高。
- 全文索引不是很常用，不如使用外部的 ElasticSearch 或 Lucene。

## InnoDB 存储引擎

该存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比 MyISAM 引擎，写的处理效率会差一些，并且会占用更多的磁盘空间以保留数据和索引。  
InnoDB 存储引擎的特点：支持自动增长列，支持外键约束，支持事务

InnoDB 中，创建的表的表结构存储在*.frm*文件中（我觉得是 frame 的缩写吧）。数据和索引存储在 innodb_data_home_dir 和 innodb_data_file_path 定义的表空间中

InnoDB：支持事务和行级锁，是 innodb 的最大特色。行锁大幅度提高了多用户并发操作的新能。

- 默认事务型引擎，最重要最广泛的存储引擎，性能非常优秀。
- 数据存储在共享表空间，可以通过配置分开。也就是多个表和索引都存储在一个表空间中，可以通过配置文件改变此配置。
- 对主键查询的性能高于其他类型的存储引擎。
- 内部做了很多优化，从磁盘读取数据时会自动构建 hash 索引，插入数据时自动构建插入缓冲区。
- 通过一些机制和工具支持真正的热备份。
- 支持崩溃后的安全恢复。
- 支持行级锁。
- 支持外键。

## MEMORY 存储引擎

Memory 存储引擎使用存在于内存中的内容来创建表。每个 memory 表只实际对应一个磁盘文件，格式是.frm。memory 类型的表访问非常的快，因为它的数据是放在内存中的，并且默认使用 HASH 索引，但是一旦服务关闭，表中的数据就会丢失掉。  
MEMORY 存储引擎的表可以选择使用 BTREE 索引或者 HASH 索引，两种不同类型的索引有其不同的使用范围

Hash 索引优点：  
Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像 B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的 IO 访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。  
Hash 索引缺点： 那么不精确查找呢，也很明显，因为 hash 算法是基于等值计算的，所以对于“like”等范围查找 hash 索引无效，不支持；

Memory 类型的存储引擎主要用于哪些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果，。对存储引擎为 memory 的表进行更新操作要谨慎，因为数据并没有实际写入到磁盘中，所以一定要对下次重新启动服务后如何获得这些修改后的数据有所考虑。

## MERGE 存储引擎

Merge 存储引擎是一组 MyISAM 表的组合，这些 MyISAM 表必须结构完全相同，merge 表本身并没有数据，对 merge 类型的表可以进行查询，更新，删除操作，这些操作实际上是对内部的 MyISAM 表进行的。

## 其他表引擎

Archive、Blackhole、CSV、Memory

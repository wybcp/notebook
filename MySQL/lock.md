# MySQL 锁机制

- 共享锁，不堵塞，多个用户可以同时读一个资源，互不干扰。
- 排他锁，一个写锁会阻塞其他的读锁和写锁，这样可以只允许一个用户进行写入，防止其他用户读取正在写入的资源。

## 锁的粒度

- 表锁，系统开销最小，会锁定整张表，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。
- 行锁，最大程度的支持并发处理， 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。InnoDB 使用行锁。
- 页级锁，介于表锁和行锁之间，NDB 使用。

## 行级锁

InnoDB 通过给索引上的索引项加锁实现，所以只有通过索引条件检索数据才使用行级锁，否则使用表级锁。

设置合适的锁等待超时阈值参数innodb_lock_wait_timeout=100，避免并发高的情况下出问题。

### 行级锁定的优点

1、当在许多线程中访问不同的行时只存在少量锁定冲突。

2、回滚时只有少量的更改

3、可以长时间锁定单一的行。

### 行级锁定的缺点

1、比页级或表级锁定占用更多的内存。

2、当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。

3、如果你在大部分数据上经常进行 GROUP BY 操作或者必须经常扫描整个表，比其它锁定明显慢很多。

4、用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。

## 乐观锁

```mysql
update table table_name
set column_name = value, version=version+1
where version = version;
```

## 悲观锁

```mysql
update table table_name set column_name = value for update;
```

## 共享锁

x 锁

- 脏读：一个事务内修改了数据，另一个事务读取并使用了这个数据；
- 幻读：一个事务内修改了涉及全表的数据，另一个事务往这个表里面插入了新的数据，第一个事务出现幻读；
- 不可重复读：一个事务内连续读了两次数据，中间另一个事务修改了这个数据，导致第一个事务前后两次读的数据不一致；
- 更新丢失：一个事务内变更了数据，另一个事务修改了这个数据，最后前一个事务 commit 导致另一个事务的变更丢失；

# 索引

索引是要占磁盘空间的。

- 索引类似于书籍的目录，要想找到一本数的某个特定主题，需要先查找书的目录，定位对应的页码
- 存储引擎使用类似的方式进行数据查询，先去索引当中找到对应的值，然后根据匹配的索引找到对应的数据行。

## why

1、数据索引的存储是有序的

2、在有序的情况下，通过索引查询一个数据是无需遍历索引记录的

3、极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N)

## Mysql 索引结构

### B+tree

b+tree 是 mysql 使用最频繁的一个索引数据结构，数据结构以平衡树的形式来组织，因为是树型结构，所以更适合用来处理排序，范围查找等功能。相对 hash 索引，B+树在查找单条记录的速度虽然比不上 hash 索引，但是因为更适合排序等操作。

1. 所有关键字都在叶子结点出现
2. 所有叶子结点增加一个链指针

### hash

hsah 索引在 mysql 比较少用，数据的索引以 hash 形式组织起来，因此当查找某一条记录的时候，速度非常快。因为是 hash 结构，每个键只对应一个值，而且是散列的方式分布，所以他并不支持范围查找和排序等功能。

#### 优势

等值查询。哈希索引具有绝对优势（前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题。）

#### 哈希索引不适用的场景

1、不支持范围查询

2、不支持索引完成排序

3、不支持联合索引的最左前缀匹配规则

通常，B+树索引结构适用于绝大多数场景，像下面这种场景用哈希索引才更有优势：

在 HEAP 表中，如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主，没有范围查询、没有排序的时候，特别适合采用哈希索引，例如这种 SQL：

```sql
select id,name from table where name='李明'; — 仅等值查询
```

而常用的 InnoDB 引擎中默认使用的是 B+树索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在 InnoDB 中默认开启自适应哈希索引），通过观察搜索模式，MySQL 会利用 index key 的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。

## 主键唯一索引 PRIMARY KEY

```sql
ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` );
```

一种特殊的唯一索引，不允许有空值。

## 唯一索引 UNIQUE

```sql
ALTER TABLE `table_name` ADD UNIQUE (`column`);
```

索引列的值必须唯一，但允许有空值。

## 普通索引 INDEX

```sql
ALTER TABLE `table_name` ADD INDEX index_name ( `column` );
```

最基本的索引，没有任何限制。

## 联合索引

```sql
 ALTER TABLE `table_name` ADD INDEX index_name ( `column1`， `column2`， `column3` );
```

为了更多的提高 mysql 效率可建立组合索引，遵循”最左前缀“原则。

## 聚簇索引

## 非聚簇索引

## 全文索引 FULLTEXT

```sql
ALTER TABLE `table_name` ADD FULLTEXT ( `column` );
```

仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗时好空间。

## 聚集索引和辅助索引、覆盖索引

- 聚集索引（主键索引）

—innodb 存储引擎是索引组织表，即表中的数据按照主键顺序存放。而聚集索引就是按照每张表的主键构造一颗 B+树，同时叶子节点中存放的即为整张表的记录数据

—聚集索引的叶子节点称为数据页，数据页，数据页！重要的事说三遍。聚集索引的这个特性决定了索引组织表中的数据也是索引的一部分。

- 辅助索引（二级索引）

—非主键索引

—叶子节点=键值+书签。Innodb 存储引擎的书签就是相应行数据的主键索引值

- 覆盖索引

如果查询的列恰好是索引的一部分，那么查询只需要在索引文件上进行，不需要进行到磁盘中找数据，若果查询得列不是索引的一部分则要到磁盘中找数据

使用 explain，可以通过输出的 extra 列来判断，对于一个索引覆盖查询，显示为**using index**，MySQL 查询优化器在执行查询前会决定是否有索引覆盖查询

## 创建索引的语法

- 首先创建一个表：create table t1 (id int primary key,username varchar(20),password varchar(20));
- 创建单个索引的语法：CREATE INDEX 索引名 on 表名（字段名）
- 索引名一般是：表名\_字段名
- 给 id 创建索引：CREATE INDEX t1_id on t1(id);
- 创建联合索引的语法：CREATE INDEX 索引名 on 表名（字段名 1，字段名 2）
- 给 username 和 password 创建联合索引：CREATE index t1_username_password ON t1(username,password)
- 其中 index 还可以替换成 unique，primary key，分别代表唯一索引和主键索引
- 删除索引：DROP INDEX t1_username_password ON t1

## 索引对性能的影响

- 大大减少服务器需要扫描的数据量。
- 帮助服务器避免排序和临时表。
- 将随机 I/O 变顺序 I/O。
- 大大提高查询速度。
- 降低写的速度（不良影响）。
- 磁盘占用（不良影响）。

## 索引的使用场景

- 对于非常小的表，大部分情况下全表扫描效率更高。
- 中到大型表，索引非常有效。
- 特大型的表，建立和使用索引的代价会随之增大，可以使用分区技术来解决。

- 主键索引一定是唯一索引，唯一索引不是主键索引。
- 主键可以与外键构成参照完整性约束，防止数据不一致。
- 联合索引：将多个列组合在一起创建索引，可以覆盖多个列。（也叫复合索引，组合索引）
- 外键索引：只有 InnoDB 类型的表才可以使用外键索引，保证数据的一致性、完整性、和实现级联操作（基本不用）。
- 全文索引：MySQL 自带的全文索引只能用于 MyISAM，并且只能对英文进行全文检索 （基本不用）

## 索引的创建原则

- 最适合创建索引的列是出现在 WHERE 或 ON 子句中的列，或连接子句中的列而不是出现在 SELECT 关键字后的列。
- 索引列的基数越大，数据区分度越高，索引的效果越好。
- 对于字符串进行索引，应该制定一个前缀长度，可以节省大量的索引空间。
- 根据情况创建联合索引，联合索引可以提高查询效率。
- 避免创建过多的索引，索引会额外占用磁盘空间，降低写操作效率。
- 主键尽可能选择较短的数据类型，可以有效减少索引的磁盘占用提高查询效率。

## 索引的注意事项

1、联合索引遵循前缀原则

```sql
KEY(a,b,c)
WHERE a = 1 AND b = 2 AND c = 3
WHERE a = 1 AND b = 2
WHERE a = 1
#以上SQL语句可以用到索引
WHERE b = 2 AND c = 3
WHERE a = 1 AND c = 3
#以上SQL语句用不到索引
```

2、LIKE 查询，%不能在前

```sql
WHERE name LIKE "%wang%"
#以上语句用不到索引，可以用外部的ElasticSearch、Lucene等全文搜索引擎替代。
```

3、列值为空（NULL）时是可以使用索引的，但 MySQL 难以优化引用了可空列的查询,它会使索引、索引统计和值更加复杂。可空列需要更多的储存空间，还需要在 MySQL 内部进行特殊处理。

4、如果 MySQL 估计使用索引比全表扫描更慢，会放弃使用索引，例如：
表中只有 100 条数据左右。对于 SQL 语句 WHERE id > 1 AND id < 100，MySQL 会优先考虑全表扫描。

5、如果关键词 or 前面的条件中的列有索引，后面的没有，所有列的索引都不会被用到。

6、列类型是字符串，查询时一定要给值加引号，否则索引失效，例如：
列 name varchar(16)，存储了字符串"100"
WHERE name = 100;
以上 SQL 语句能搜到，但无法用到索引。

InnoDB 通过主键聚簇数据，如果没有定义主键，会选择一个唯一的非空索引代替，如果没有这样的索引，会隐式定义个主键作为聚簇索引。

- 1）插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个自增的 ID 列为主键。
- 2）更新主键的代价很高，因为将会导致被更新的行移动。因此，对于 InnoDB 表，我们一般定义主键为不可更新。
- 3）二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。

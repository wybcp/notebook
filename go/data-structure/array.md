# 数组

数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，因此在 Go 语言中很少直接使用数组。和数组对应的类型是 Slice（切片）。

在数组字面值中，如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的个数来计算。因此，上面 q 数组的定义可以简化为

```Go
q := [...]int{1, 2, 3}
```

同样的子元素类型并且是同样长度的数组才可以相互赋值，否则就是不同的数组类型，不能赋值。数组的赋值本质上是一种浅拷贝操作，赋值的两个数组变量的值不会共享。

```go
package main

import "fmt"

func main() {
    var a = [9]int{1, 2, 3, 4, 5, 6, 7, 8, 9}
    var b [9]int
    b = a
    a[0] = 12345
    fmt.Println(a)
    fmt.Println(b)
}

--------------------------
[12345 2 3 4 5 6 7 8 9]
[1 2 3 4 5 6 7 8 9]
```

如果数组的长度很大，那么拷贝操作是有一定的开销的，使用的时候一定需要注意。

## 指针数组

指针数组和数组本身差不多，只不过元素类型是指针。

```go
array := [5]*int{1: new(int), 3:new(int)}
spew.Dump(array)
// ([5]*int) (len=5 cap=5) {
//  (*int)(<nil>),
//  (*int)(0xc00009c160)(0),
//  (*int)(<nil>),
//  (*int)(0xc00009c168)(0),
//  (*int)(<nil>)
// }
```

这样就创建了一个指针数组，并且为索引 1 和 3 都创建了内存空间，其他索引是指针的零值 nil,这时候我们要修改指针变量的值也很简单，如下即可：

```go
array := [5]*int{1: new(int), 3:new(int)}
*array[1] = 1
```

以上需要注意的是，只可以给索引 1 和 3 赋值，因为只有它们分配了内存，才可以赋值，如果我们给索引 0 赋值，运行的时候，会提示无效内存或者是一个 nil 指针引用。

panic: runtime error: invalid memory address or nil pointer dereference

要解决这个问题，我们要先给索引 0 分配内存，然后再进行赋值修改。

```go
array := [5]*int{1: new(int), 3:new(int)}
array[0] =new(int)
*array[0] = 2
spew.Dump(array)
// ([5]*int) (len=5 cap=5) {
//  (*int)(0xc0000161f0)(2),
//  (*int)(0xc0000161e0)(0),
//  (*int)(<nil>),
//  (*int)(0xc0000161e8)(0),
//  (*int)(<nil>)
// }
```

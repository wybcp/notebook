# 缓存设计

缓存能有效地加速应用的读取速度，降低后端负载，在实际应用中需要合理设计。

## 缓存更新策略

|         策略          |                 实现方式                 | 数据一致性 | 维护成本 |
| :-------------------: | :--------------------------------------: | :--------: | :------: |
| LRU/LFU/FIFO 算法剔除 | 通常使用预设最大缓存值来实现数据的剔除。 |    最差    |    低    |
|       超时剔除        |            设置过期时间来实现            |    较差    |   较低   |
|       主动更新        |   存储数据更新后，立刻主动更新缓存数据   |     好     |    高    |

建议：

* 高一致性配置：结合超时剔除和主动更新
* 低一致性配置：最大内存策略

##　缓存颗粒度控制

## 穿透优化

缓存穿透是指查询一个根本不存在的数据，在缓冲层和存储层都不会命中。

原因：

- 恶意攻击、爬虫等
- 自身代码或数据出了问题

缓存穿透导致缓存层无法保护存储层，后端负载加大。

### 1.缓存空对象

产生的问题：

- 浪费存储内存（尤其是恶意攻击产生大量空对象），可以设置较短的过期时间删除
- 数据不一致，可以用其他方式主动更新

### 2.Bool过滤器拦截

将存在的 key 用 Bool 过滤器提前保存，作为第一层，然后才是缓存层和存储层。

## 热点 key 重建优化

在缓存失效的瞬间，有大量的线程来重建缓存，造成后端负载过大。

解决方案：

- 互斥锁
- 永不过期：可能造成数据不一致。
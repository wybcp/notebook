# GEO

Redis 3.2 版本提供地理信息定位，支持存储地理位置来实现附近位置、摇一摇等功能。

## 命令：

- `geoadd key longtitude latitude member [longtitude latitude member ...]`： longtitude-经度，有效范围为-180 到 180 度； latitude-纬度,有效维度范围为-85.05112878 到 85.05112878 度（靠近南北极的一小块地方是无法生成索引的）。返回成功后添加个数。
- [`geodist key member1 member2 [unit]`](https://redis.io/commands/geodist): 获取两个地理位置的距离,unit 有四个：m、km、mi、ft。
- `geohash key member`： 获取地理位置的 GeoHash 值。
- `geopos key member`：获取地理位置的坐标。
- `zrem key member`：删除地理信息。
- `georadius key longtitude latitude radius m|km|mi|ft`： 根据给定经纬度坐标获取指定范围内的地理位置集合。
- [`georadiusbymember key member radius m|km|mi|ft`](https://redis.io/commands/georadiusbymember)： 根据给定地理位置获取指定范围内的地理位置集合。

## GeoHash 基本原理

GeoHash 是一种地址编码，通过切分地图区域为小方块（切分次数越多，精度越高），它能把二维的经纬度编码成一维的字符串。也就是说，理论上 geohash 字符串表示的并不是一个点，而是一个矩形区域，只要矩形区域足够小，达到所需精度即可。

### 编码过程

以经纬度（116.3906，39.92324）为例：

1. 对于维度 39.92324， 39.92324 属于(0, 90)，所以取编码为 1。然后再将(0, 90)分成 (0, 45), (45, 90)两个区间，而 39.92324 位于(0, 45)，所以编码为 0。以此类推，直到精度符合要求为止，得到纬度编码为 1011 1000 1100 0111 1001。
1. 经度也用同样的算法，对(-180, 180)依次细分，得到 116.3906 的编码为 1101 0010 1100 0100 0100。
1. 接下来将经度和纬度的编码合并，奇数位是纬度，偶数位是经度，得到编码 11100 11101 00100 01111 00000 01101 01011 00001。
1. 最后，用 0-9、b-z（去掉 a, i, l, o）这 32 个字母进行 base32 编码，得到(39.92324, 116.3906)的编码为 wx4g0ec1。

（116.3906，39.92324）对应的地图位置就是 `http://geohash.org/wx4g0ec1`，降低一些精度，就会是`http://geohash.org/wx4g0ec`，再降低一些精度，就会是 `http://geohash.org/wx4g0`。

### 编码特性

不难看出这样的编码方式仅用一个字符串保存经纬度信息，并且精度由字符串从头到尾的长度决定，编码长度越长，精度越高。GeoHash 值的前缀相同的位数越多，代表的位置越接近，可以方便索引。

但这种方案的缺点是：从 geohash 的编码算法中可以看出，靠近每个方块边界两侧的点虽然十分接近，但所属的编码会完全不同。实际应用中，需要通过去搜索环绕当前方块周围的 8 个方块来解决该问题。

除此之外，这个方案也无法直接得到距离，需要程序协助进行后续的排序计算。

## 建议

建议 Geo 的数据使用单独的 Redis 实例部署，不使用集群环境。

如果数据量过亿甚至更大，就需要对 Geo 数据进行拆分，按国家拆分、按省拆分，按市拆分，在人口特大城市甚至可以按区拆分。这样就可以显著降低单个 zset 集合的大小。

## 参考

- <https://yq.aliyun.com/articles/62844>
- [应用 8：近水楼台 —— GeoHash](https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b3b2e106fb9a04fcf59acb8)
